package org.coralibre.android.sdk.internal.crypto;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import org.coralibre.android.sdk.internal.database.Database;
import org.coralibre.android.sdk.internal.database.DatabaseAccess;
import org.coralibre.android.sdk.internal.database.model.GeneratedTEK;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.Arrays;

import static org.coralibre.android.sdk.internal.crypto.AssociatedMetadata.AEM_LENGTH;
import static org.coralibre.android.sdk.internal.crypto.RollingProximityIdentifier.RPI_LENGTH;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

@RunWith(AndroidJUnit4.class)
public class CryptoModuleTests {

    private static final byte[] TEK_VAL1 = ByteHelper.hexStringToByteArray("12345667789ABCDEF123456789ABCDEF");

    //value generated by hkdf.py
    //hkdf code was taken from https://en.wikipedia.org/wiki/HKDF#Example:_Python_implementation
    private static final byte[] RPIK_VAL1 = new byte[] {
            (byte) 249,
            (byte) 156,
            (byte) 130,
            (byte) 43,
            (byte) 122,
            (byte) 202,
            (byte) 124,
            (byte) 152,
            (byte) 91,
            (byte) 88,
            (byte) 171,
            (byte) 163,
            (byte) 126,
            (byte) 114,
            (byte) 30,
            (byte) 19,
    };

    private static final byte[] AEMK_VAL1 = new byte[] {
            (byte) 165,
            (byte) 243,
            (byte) 80,
            (byte) 172,
            (byte) 127,
            (byte) 63,
            (byte) 77,
            (byte) 120,
            (byte) 194,
            (byte) 162,
            (byte) 245,
            (byte) 33,
            (byte) 108,
            (byte) 134,
            (byte) 125,
            (byte) 231,
    };

    private static final byte[] RPI_VAL1 = new byte[] {
            61,
            -78,
            -88,
            -126,
            104,
            -111,
            35,
            -19,
            51,
            72,
            120,
            -35,
            -45,
            -110,
            -111,
            -7
    };

    private static final AssociatedMetadata mockAem = new AssociatedMetadata(1, 0, -2);

    private static final byte[] AM_VAL_V3_2_MINUS16db = {(byte) 0b11100000, (byte) 0xF0, 0x00, 0x00};

    private static final byte[] TEK_VAL2 = ByteHelper.hexStringToByteArray("2765f41dbaa6306a264391913bf48723");
    private static final byte[] TEK_VAL2_RPIK = ByteHelper.hexStringToByteArray("34fbbd748ee78bb386d1bab2df7b4165");
    private static final byte[] TEK_VAL2_RPI_1 = ByteHelper.hexStringToByteArray("31fc2cf219fe6dc6765d860e979ba9e5");
    private static final byte[] TEK_VAL2_AEMK = ByteHelper.hexStringToByteArray("e01962eba7d4b5f40226e91ef9f6c050");
    private static final byte[] TEK_VAL2_AEM = ByteHelper.hexStringToByteArray("10413a43");

    private static final byte[] TEK_VAL3 = ByteHelper.hexStringToByteArray("7921b817fdb92074df5345594273756f");
    private static final byte[] TEK_VAL3_RPIK = ByteHelper.hexStringToByteArray("eae8956644770f952871daf549c0ce7e");
    private static final byte[] TEK_VAL3_RPI_1 = ByteHelper.hexStringToByteArray("5811408cf8d88d2b33f73773a7c6d45f");
    private static final byte[] TEK_VAL3_AEMK = ByteHelper.hexStringToByteArray("a1d0bd6f94b053cf622ca88194e20611");
    private static final byte[] TEK_VAL3_AEM = ByteHelper.hexStringToByteArray("a3e9517f");


    @BeforeClass
    public static void initGlobal() {
        // Static, since otherwise JUnit throws an exception:
        // https://stackoverflow.com/questions/733037/why-isnt-my-beforeclass-method-running/733042#733042
        // Also see:
        // https://stackoverflow.com/questions/52873173/migrating-junit4-tests-to-androidx-what-causes-delegate-runner-could-not-be-lo

        DatabaseAccess.init(InstrumentationRegistry.getInstrumentation().getContext());
    }

    @AfterClass
    public static void deInit() {
        // If this call is not performed, tests from other classes where the database's init is
        // called might not run, since db reinitialization would throw an exception:
        DatabaseAccess.deInit();
    }

    @Before
    public void clearDb() {
        DatabaseAccess.getDefaultDatabaseInstance().clearAllData();
    }


    private static CryptoModule getMockedTimeCryptoModule(Database db, long ennumber) throws Exception {
        Class cryptoModuleClass = Class.forName("org.coralibre.android.sdk.internal.crypto.CryptoModule");
        Constructor<CryptoModule>  cryptoModuleConstructor = cryptoModuleClass.getDeclaredConstructor(Database.class, ENInterval.class);
        cryptoModuleConstructor.setAccessible(true);
        return cryptoModuleConstructor.newInstance(db, new ENInterval(ennumber));
    }

    private static void setCurrentENNumber(CryptoModule cryptoModule, long newennumber) throws Exception {
        Field currentIntervalField = CryptoModule.class.getDeclaredField("currentIntervalForTesting");
        currentIntervalField.setAccessible(true);
        currentIntervalField.set(cryptoModule, new ENInterval(newennumber));
    }

    @Test
    public void testGetCurrentInterval() {
        assertEquals(CryptoModule.getCurrentInterval(), new ENInterval(System.currentTimeMillis() / 1000L, true));
    }

    @Test
    public void testGenerateRPIK() throws Exception {
        TemporaryExposureKey tek = new TemporaryExposureKey(0L, TEK_VAL1);
        RollingProximityIdentifierKey rpik = CryptoModule.generateRPIK(tek);
        assertArrayEquals(RPIK_VAL1, rpik.getKey());
    }

    @Test
    public void testGenerateAEMK() throws Exception {
        TemporaryExposureKey tek = new TemporaryExposureKey(0L, TEK_VAL1);
        AssociatedEncryptedMetadataKey aemk = CryptoModule.generateAEMK(tek);
        assertArrayEquals(AEMK_VAL1, aemk.getKey());
    }

    @Test
    public void testEncryptDecryptRPI() throws Exception {
        RollingProximityIdentifierKey rpik = new RollingProximityIdentifierKey(RPIK_VAL1);
        //encrypt
        RollingProximityIdentifier rpi = new CryptoModule(DatabaseAccess.getDefaultDatabaseInstance()).generateRPI(rpik);
        //decrypt
        PaddedData pd = CryptoModule.decryptRPI(rpi, rpik);
        assertTrue("RPI decryption failed", pd.isRPIInfoValid());
    }

    @Test
    public void testEncryptDecryptAEM() throws Exception {
        AssociatedMetadata am = new AssociatedMetadata(AM_VAL_V3_2_MINUS16db);
        RollingProximityIdentifier rpi = new RollingProximityIdentifier(RPI_VAL1,
                new ENInterval(0));
        AssociatedEncryptedMetadataKey aemk = new AssociatedEncryptedMetadataKey(AEMK_VAL1);

        AssociatedEncryptedMetadata aem = CryptoModule.encryptAM(am, rpi, aemk);
        AssociatedMetadata decryptedAM = CryptoModule.decryptAEM(aem, rpi, aemk);
        assertArrayEquals(am.getData(), decryptedAM.getData());
    }

    @Test
    // See: https://github.com/corona-warn-app/cwa-app-android/issues/75#issuecomment-640114705
    public void testRoundtripExample1() throws Exception {
        TemporaryExposureKey tek = new TemporaryExposureKey(0L, TEK_VAL2);
        RollingProximityIdentifierKey rpik = CryptoModule.generateRPIK(tek);
        assertArrayEquals(TEK_VAL2_RPIK, rpik.getKey());
        ENInterval enInterval = new ENInterval(2652091);
        RollingProximityIdentifier rpi = CryptoModule.generateRPI(rpik, enInterval);
        assertArrayEquals(TEK_VAL2_RPI_1, rpi.getData());

        AssociatedEncryptedMetadataKey aemk = CryptoModule.generateAEMK(tek);
        assertArrayEquals(TEK_VAL2_AEMK, aemk.getKey());

        AssociatedEncryptedMetadata aem = new AssociatedEncryptedMetadata(TEK_VAL2_AEM);
        AssociatedMetadata am = CryptoModule.decryptAEM(aem, rpi, aemk);
        assertEquals(-14, am.getTransmitPowerLevel());
    }

    @Test
    // See: https://github.com/corona-warn-app/cwa-app-android/issues/75#issuecomment-640114705
    public void testRoundtripExample2() throws Exception {
        TemporaryExposureKey tek = new TemporaryExposureKey(0L, TEK_VAL3);
        RollingProximityIdentifierKey rpik = CryptoModule.generateRPIK(tek);
        assertArrayEquals(TEK_VAL3_RPIK, rpik.getKey());
        ENInterval enInterval = new ENInterval(2649435);
        RollingProximityIdentifier rpi = CryptoModule.generateRPI(rpik, enInterval);
        assertArrayEquals(TEK_VAL3_RPI_1, rpi.getData());

        AssociatedEncryptedMetadataKey aemk = CryptoModule.generateAEMK(tek);
        assertArrayEquals(TEK_VAL3_AEMK, aemk.getKey());

        AssociatedEncryptedMetadata aem = new AssociatedEncryptedMetadata(TEK_VAL3_AEM);
        AssociatedMetadata am = CryptoModule.decryptAEM(aem, rpi, aemk);
        assertEquals(12, am.getTransmitPowerLevel());
    }

    @Test
    public void testInitialTEKGeneration() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db, 1000);
        int i = 0;
        for(GeneratedTEK tek : db.getAllGeneratedTEKs())
            i++;
        assertEquals(1, i);
    }

    @Test
    public void testUpdateTEKDontUpdateOnSameDay() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db,1050);
        setCurrentENNumber(crypto, 1100);
        crypto.updateTEK();
        int i = 0;
        for(GeneratedTEK tek : db.getAllGeneratedTEKs())
            i++;
        assertEquals(1, i);
    }

    @Test
    public void testUpdateTEKUpdateOnDifferentDays() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db, 1000);
        setCurrentENNumber(crypto, 1100);
        crypto.updateTEK();
        int i = 0;
        for(GeneratedTEK tek : db.getAllGeneratedTEKs())
            i++;
        assertEquals(2, i);
    }

    @Test
    public void testGetCurrentRPI() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db, 1000);
        crypto.setMetadata(mockAem);
        crypto.renewPayload();
        BluetoothPayload payload = crypto.getCurrentPayload();
        assertEquals(AEM_LENGTH, payload.getAem().getData().length);
        assertEquals(1000, payload.getInterval().get());
        assertEquals(RPI_LENGTH, payload.getRpi().getData().length);
    }

    @Test
    public void testGetCurrentRPINotRollingWithinOneInterval() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db, 1000);
        crypto.setMetadata(mockAem);
        crypto.renewPayload();
        BluetoothPayload payload1 = crypto.getCurrentPayload();
        crypto.renewPayload();
        BluetoothPayload payload2 = crypto.getCurrentPayload();
        assertEquals(1000, payload1.getInterval().get());
        assertEquals(1000, payload2.getInterval().get());
        assertArrayEquals(payload1.getAem().getData(), payload2.getAem().getData());
        assertArrayEquals(payload1.getRpi().getData(), payload2.getRpi().getData());
    }

    @Test
    public void testGetCurrentRPIRollingWithinDifferentIntervals() throws Exception {
        Database db = DatabaseAccess.getDefaultDatabaseInstance();
        CryptoModule crypto = getMockedTimeCryptoModule(db,1000);
        crypto.setMetadata(mockAem);
        crypto.renewPayload();
        BluetoothPayload payload1 = crypto.getCurrentPayload();
        setCurrentENNumber(crypto, 1001);
        crypto.renewPayload();
        BluetoothPayload payload2 = crypto.getCurrentPayload();
        assertEquals(1000, payload1.getInterval().get());
        assertEquals(1001, payload2.getInterval().get());
        assertFalse(Arrays.equals(payload1.getAem().getData(), payload2.getAem().getData()));
        assertFalse(Arrays.equals(payload1.getRpi().getData(), payload2.getRpi().getData()));
    }
}
